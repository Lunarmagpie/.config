#!/bin/env python

import os
import subprocess
import dataclasses
import shlex

from desktop_parser import DesktopFile

GOTO_PREFIX = "GOTO: "


@dataclasses.dataclass
class Application:
    name: str
    icon: str
    exec: str
    path: str


def parse_desktop(file: str) -> Application | None:
    name = None
    icon = ""
    exec = None

    try:
        with open(file) as f:
            contents = f.read()
    except Exception:
        return None

    for line in contents.splitlines():
        if line.startswith("Name=") and not name:
            name = line.removeprefix("Name=")
        if line.startswith("Exec=") and not exec:
            exec = line.removeprefix("Exec=")
        if line.startswith("Icon=") and not icon:
            icon = line.removeprefix("Icon=")

    if name is None or exec is None:
        return None

    return Application(name, icon, exec, file)


def open_path(path: str) -> list[Application]:
    if not os.path.exists(path):
        return []

    out = []

    for file in os.listdir(path):
        if os.path.isdir(path + "/" + file):
            out.extend(open_path(path + "/" + file))
            continue
        app = parse_desktop(path + "/" + file)
        if app != None:
            out.append(app)

    return out


def open_apps():
    dirs = os.environ.get("XDG_DATA_DIRS", "")
    XDG_PATHS = dirs.split(":")

    paths = []
    for path in XDG_PATHS:
        paths.extend(open_path(path + "/applications"))
    return paths


apps = open_apps()


# Get path
path1 = subprocess.run(
    f"""swaymsg -t get_tree |
         jq  -r  '.nodes[].nodes[]  |  if  .nodes  then  [recurse(.nodes[])]  else   []   end   +
       .floating_nodes | .[] | select(.nodes==[]) | ("{GOTO_PREFIX}" + (.id | tostring) + " " + .name)'""",
    shell=True,
    capture_output=True,
).stdout.decode("utf8")


def name(app):
    if app.icon:
        return f"{app.name}\x00icon\x1f{app.icon}"
    return app.name


path2 = "\n".join([name(app) for app in apps])

paths = f"{path1}\n{path2}"

res = subprocess.run(
    ["fuzzel", "-d"], capture_output=True, input=paths.encode("utf8")
).stdout.decode("utf8")

if not res:
    exit()

custom_command = False

if res.startswith("/"):
    custom_command = True
elif res.startswith(GOTO_PREFIX):
    id = res.strip(GOTO_PREFIX).split(" ")[0].strip()
    subprocess.run(["swaymsg", f"[con_id={id}]", "focus"])
elif res.strip() in path2:
    # find the command
    for x in reversed(apps):
        if res.strip() in x.name:
            cmd = x.exec.replace("%u", "").replace("%U", "").replace("%f", "")
            subprocess.run(cmd, shell=True)
            exit()
else:
    custom_command = True

if custom_command:
    print("Running custom command")
    if res.startswith("/"):
        res = res[1:]

    if res.startswith("eval"):
        name = res.strip().removeprefix("eval") + "="
        try:
            o = str(eval(res.removeprefix("eval")))
        except Exception as e:
            name = ""
            o = str(e)
    else:
        # This is a terminal command
        name = res
        p = subprocess.run(res, shell=True, capture_output=True, check=True)
        if p.stdout:
            o = p.stdout.decode("utf8")
        elif p.stderr:
            o = p.stderr.decode("utf8")

    subprocess.run(["notify-send", f"{name}{o}"])
